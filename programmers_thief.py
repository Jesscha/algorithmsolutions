# 동적계획법(Dynamic Programming) >  도둑질


def solution(money):
    # 첫번쨰를 무조건 차용하지 않음
    dp0 = [0 for _ in range(len(money))]
    # 첫번쨰를 무조건 차용함 
    dp1 = [0 for _ in range(len(money))]
    dp0[0] = 0 
    dp0[1] = money[1]

    dp1[0] = money[0]
    dp1[1] = max(money[0], money[1])
    length = len(money) -1
    
    for i in range(2, len(money)):
        # 첫번째 거를 사용한 dp는 마지막을 무조건 사용할 수 없다. 
        if i == length:
            dp1[i] = dp1[i-1]
        else:
            dp1[i] = max(dp1[i-1], dp1[i-2]+money[i])
        dp0[i] = max(dp0[i-1], dp0[i-2]+money[i])
    answer = max(dp0[length], dp1[length])
    return answer

print(solution([1, 2, 3, 1]))


'''
생각해 보자 

개인적으로 dp에서 가장 중요한 일은 어떤 걸 기준으로 점화식을 세우느냐 인 것 같다. 

나는 집의 개수를기준으로 점화식을 세우려 해서 접근의 실마리를 잡을 수 없었다. 

다른 사람들의 풀이를 보니, 집개수를 기준으로 하는게 아니라, 특정 집의 인덱스 번호를 기준으로 생각하더라 

이제 힌트를 얻었으니 다시 생각해 보자 

1번째 집 까지 털 수 있는 최대 수는 1번집의 최댓 값

2번째 집까지 털 수 있는 최대 수는 1번 아니면 2번집 최대 값

3번째 집까지는 1번에 3번을 더한 것과 2번중 큰 것 

4번째 집까지는 3번째 집까지 하는 것과 2번째 집까지 더한 것 중 큰 것 

즉 직전거가 되던지, 전전거에 본인을 더한것에 대해 더 큰 값을 가지면 된다. 

d[i] = max(d[i-2] + i, d[i-1])

하지만 여기서 고려해야 하는 것이 하나 더 있다. 바로 맨 뒤의 집은 맨앞에 집과 서로 이웃 사이 라는 것 

맨 뒤의 집인 경우에만 특별 케이스를 추가하는 식으로 풀 수 없을까? 그러기에는 이미 너무 먼 길을 와 버렸네 

이를 해결하기 위해서는 0번째 집을 턴 경우, 털지 않은 경우로 나누어서 dp를 하는 편이 좋지 않을까 


dp의 시작을 1부터로 하고 0시점을 0으로 하냐 0번째 집으로하냐의 문제로 만들면 될 듯 

그렇게 마지막 집까지 계산을 마치고 dp1이랑 dp2 중에 최댓 값을 구하면 되지 않을까?

맨처음껄 넣은 경우에는 마지막꺼는 무조건 안넣게 하는 식으로 계산하고 하면 될 듯









'''